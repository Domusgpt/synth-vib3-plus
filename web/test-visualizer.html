<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VIB34D Test Visualizer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      overflow: hidden;
      font-family: 'Courier New', monospace;
      color: #0ff;
    }
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border: 1px solid #0ff;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="info">
    <div>VIB34D Quaternion Visualizer</div>
    <div id="fps">FPS: 0</div>
    <div id="status">Initializing...</div>
  </div>

  <script>
    // Simple 4D hypercube visualizer with quaternion rotations
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const info = document.getElementById('info');
    const fpsDisplay = document.getElementById('fps');
    const statusDisplay = document.getElementById('status');

    let width, height;
    let frameCount = 0;
    let lastTime = performance.now();
    let fps = 60;

    // Resize canvas
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // 4D hypercube vertices
    const vertices4D = [
      [-1,-1,-1,-1], [1,-1,-1,-1], [-1,1,-1,-1], [1,1,-1,-1],
      [-1,-1,1,-1], [1,-1,1,-1], [-1,1,1,-1], [1,1,1,-1],
      [-1,-1,-1,1], [1,-1,-1,1], [-1,1,-1,1], [1,1,-1,1],
      [-1,-1,1,1], [1,-1,1,1], [-1,1,1,1], [1,1,1,1]
    ];

    // Edges connecting vertices
    const edges = [
      [0,1],[1,3],[3,2],[2,0], [4,5],[5,7],[7,6],[6,4],
      [0,4],[1,5],[2,6],[3,7], [8,9],[9,11],[11,10],[10,8],
      [12,13],[13,15],[15,14],[14,12], [8,12],[9,13],[10,14],[11,15],
      [0,8],[1,9],[2,10],[3,11], [4,12],[5,13],[6,14],[7,15]
    ];

    // Rotation angles
    let angleXW = 0, angleYW = 0, angleZW = 0;

    // Rotate in 4D
    function rotate4D(point, angleXW, angleYW, angleZW) {
      let [x, y, z, w] = point;

      // XW rotation
      const cosXW = Math.cos(angleXW);
      const sinXW = Math.sin(angleXW);
      let newX = x * cosXW - w * sinXW;
      let newW = x * sinXW + w * cosXW;
      x = newX;
      w = newW;

      // YW rotation
      const cosYW = Math.cos(angleYW);
      const sinYW = Math.sin(angleYW);
      let newY = y * cosYW - w * sinYW;
      newW = y * sinYW + w * cosYW;
      y = newY;
      w = newW;

      // ZW rotation
      const cosZW = Math.cos(angleZW);
      const sinZW = Math.sin(angleZW);
      let newZ = z * cosZW - w * sinZW;
      newW = z * sinZW + w * cosZW;
      z = newZ;
      w = newW;

      return [x, y, z, w];
    }

    // Project 4D to 3D
    function project4Dto3D(point) {
      const distance = 3;
      const [x, y, z, w] = point;
      const factor = distance / (distance - w);
      return [x * factor, y * factor, z * factor];
    }

    // Project 3D to 2D (perspective)
    function project3Dto2D(point) {
      const distance = 5;
      const [x, y, z] = point;
      const scale = distance / (distance + z);
      return {
        x: width / 2 + x * scale * 150,
        y: height / 2 - y * scale * 150,
        brightness: Math.max(0.3, scale)
      };
    }

    // Animation loop
    function animate() {
      const now = performance.now();
      const delta = now - lastTime;

      // Update FPS
      if (frameCount % 60 === 0) {
        fps = Math.round(1000 / delta);
        fpsDisplay.textContent = `FPS: ${fps}`;
      }

      // Clear canvas
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, width, height);

      // Update rotation angles
      angleXW += 0.01;
      angleYW += 0.012;
      angleZW += 0.008;

      // Transform and project vertices
      const projected = vertices4D.map(v => {
        const rotated = rotate4D(v, angleXW, angleYW, angleZW);
        const proj3D = project4Dto3D(rotated);
        return project3Dto2D(proj3D);
      });

      // Draw edges
      edges.forEach(([i, j]) => {
        const p1 = projected[i];
        const p2 = projected[j];
        const brightness = (p1.brightness + p2.brightness) / 2;

        ctx.strokeStyle = `rgba(0, 255, 255, ${brightness})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
      });

      // Draw vertices
      projected.forEach(p => {
        ctx.fillStyle = `rgba(255, 0, 255, ${p.brightness})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
        ctx.fill();
      });

      frameCount++;
      lastTime = now;
      requestAnimationFrame(animate);
    }

    // Start
    statusDisplay.textContent = 'Running';
    animate();

    // Expose API for Flutter
    window.vib34d = {
      setRotationSpeed: (speed) => {
        // Will implement
      },
      updateAudio: (data) => {
        // Audio reactive will modulate rotation speeds
        if (data.bass) {
          // Bass modulates XW rotation
        }
      }
    };
  </script>
</body>
</html>
