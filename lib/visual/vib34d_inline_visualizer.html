<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>VIB34D 4D Hypercube Visualizer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      overflow: hidden;
      font-family: 'Courier New', monospace;
      touch-action: none;
    }
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script>
    /**
     * VIB34D Inline 4D Hypercube Visualizer
     * Pure JavaScript - No ES6 imports - Self-contained
     *
     * Features:
     * - 4D hypercube (tesseract) with 16 vertices, 32 edges
     * - Quaternion-based rotations in XW, YW, ZW planes
     * - 4D → 3D → 2D projection pipeline
     * - Audio-reactive modulation
     * - Three visualization modes: quantum, holographic, faceted
     *
     * A Paul Phillips Manifestation
     */

    // Canvas setup
    var canvas = document.getElementById('canvas');
    var ctx = canvas.getContext('2d');
    var width, height;

    // Animation state
    var frameCount = 0;
    var lastTime = performance.now();
    var fps = 60;

    // 4D hypercube vertices (16 vertices of tesseract)
    var vertices4D = [
      [-1,-1,-1,-1], [1,-1,-1,-1], [-1,1,-1,-1], [1,1,-1,-1],
      [-1,-1,1,-1], [1,-1,1,-1], [-1,1,1,-1], [1,1,1,-1],
      [-1,-1,-1,1], [1,-1,-1,1], [-1,1,-1,1], [1,1,-1,1],
      [-1,-1,1,1], [1,-1,1,1], [-1,1,1,1], [1,1,1,1]
    ];

    // Edges connecting vertices (32 edges)
    var edges = [
      // Inner cube (w = -1)
      [0,1],[1,3],[3,2],[2,0], [4,5],[5,7],[7,6],[6,4],
      [0,4],[1,5],[2,6],[3,7],
      // Outer cube (w = 1)
      [8,9],[9,11],[11,10],[10,8], [12,13],[13,15],[15,14],[14,12],
      [8,12],[9,13],[10,14],[11,15],
      // Connections between cubes
      [0,8],[1,9],[2,10],[3,11], [4,12],[5,13],[6,14],[7,15]
    ];

    // Rotation angles (radians)
    var angleXW = 0;
    var angleYW = 0;
    var angleZW = 0;

    // Rotation speeds (radians per frame)
    var speedXW = 0.01;
    var speedYW = 0.012;
    var speedZW = 0.008;

    // Visual parameters
    var hueShift = 0;
    var glowIntensity = 1.0;
    var vertexBrightness = 1.0;
    var tessellationDensity = 1.0; // Scale factor for rendering

    // Audio reactive state
    var audioReactive = {
      bass: 0.0,
      mid: 0.0,
      high: 0.0,
      energy: 0.0
    };

    // Current visualization mode
    var currentMode = 'quantum'; // quantum, holographic, faceted

    // Resize handler
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // 4D rotation in XW plane
    function rotateXW(point, angle) {
      var x = point[0], y = point[1], z = point[2], w = point[3];
      var cos = Math.cos(angle);
      var sin = Math.sin(angle);
      return [
        x * cos - w * sin,
        y,
        z,
        x * sin + w * cos
      ];
    }

    // 4D rotation in YW plane
    function rotateYW(point, angle) {
      var x = point[0], y = point[1], z = point[2], w = point[3];
      var cos = Math.cos(angle);
      var sin = Math.sin(angle);
      return [
        x,
        y * cos - w * sin,
        z,
        y * sin + w * cos
      ];
    }

    // 4D rotation in ZW plane
    function rotateZW(point, angle) {
      var x = point[0], y = point[1], z = point[2], w = point[3];
      var cos = Math.cos(angle);
      var sin = Math.sin(angle);
      return [
        x,
        y,
        z * cos - w * sin,
        z * sin + w * cos
      ];
    }

    // Combined 4D rotation
    function rotate4D(point, angleXW, angleYW, angleZW) {
      var p = rotateXW(point, angleXW);
      p = rotateYW(p, angleYW);
      p = rotateZW(p, angleZW);
      return p;
    }

    // Project 4D to 3D (perspective projection from 4D)
    function project4Dto3D(point) {
      var distance = 3.0;
      var w = point[3];
      var factor = distance / (distance - w);
      return [
        point[0] * factor,
        point[1] * factor,
        point[2] * factor
      ];
    }

    // Project 3D to 2D (perspective projection for screen)
    function project3Dto2D(point) {
      var distance = 5.0;
      var z = point[2];
      var scale = distance / (distance + z);
      var screenScale = Math.min(width, height) * 0.15 * tessellationDensity;
      return {
        x: width / 2 + point[0] * scale * screenScale,
        y: height / 2 - point[1] * scale * screenScale,
        brightness: Math.max(0.2, Math.min(1.0, scale * vertexBrightness))
      };
    }

    // Color generation with hue shift
    function getColor(brightness, alpha) {
      var hue = (hueShift + frameCount * 0.5) % 360;

      if (currentMode === 'quantum') {
        // Cyan-Magenta quantum palette
        var r = Math.floor(brightness * 255 * (0.5 + Math.sin(hue * 0.017) * 0.5));
        var g = Math.floor(brightness * 255 * 0.8);
        var b = Math.floor(brightness * 255);
        return 'rgba(' + r + ',' + g + ',' + b + ',' + alpha + ')';
      } else if (currentMode === 'holographic') {
        // Holographic rainbow palette
        var r = Math.floor(brightness * 255 * (0.5 + Math.sin((hue + 0) * 0.017) * 0.5));
        var g = Math.floor(brightness * 255 * (0.5 + Math.sin((hue + 120) * 0.017) * 0.5));
        var b = Math.floor(brightness * 255 * (0.5 + Math.sin((hue + 240) * 0.017) * 0.5));
        return 'rgba(' + r + ',' + g + ',' + b + ',' + alpha + ')';
      } else { // faceted
        // Geometric green-blue palette
        var r = Math.floor(brightness * 50);
        var g = Math.floor(brightness * 255);
        var b = Math.floor(brightness * 200);
        return 'rgba(' + r + ',' + g + ',' + b + ',' + alpha + ')';
      }
    }

    // Main render function
    function render() {
      var now = performance.now();
      var delta = now - lastTime;

      // Update FPS
      if (frameCount % 60 === 0) {
        fps = Math.round(1000 / delta);
      }

      // Clear canvas with glow effect
      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'; // Trails effect
      ctx.fillRect(0, 0, width, height);

      // Apply audio reactivity to rotation speeds
      if (audioReactive.bass > 0) {
        speedXW = 0.01 + audioReactive.bass * 0.03;
      }
      if (audioReactive.mid > 0) {
        speedYW = 0.012 + audioReactive.mid * 0.025;
      }
      if (audioReactive.high > 0) {
        speedZW = 0.008 + audioReactive.high * 0.02;
      }

      // Update rotation angles
      angleXW += speedXW;
      angleYW += speedYW;
      angleZW += speedZW;

      // Transform and project all vertices
      var projected = [];
      for (var i = 0; i < vertices4D.length; i++) {
        var rotated = rotate4D(vertices4D[i], angleXW, angleYW, angleZW);
        var proj3D = project4Dto3D(rotated);
        var proj2D = project3Dto2D(proj3D);
        projected.push(proj2D);
      }

      // Draw edges with glow
      ctx.lineWidth = 2;
      ctx.shadowBlur = 10 * glowIntensity;

      for (var i = 0; i < edges.length; i++) {
        var edge = edges[i];
        var p1 = projected[edge[0]];
        var p2 = projected[edge[1]];
        var avgBrightness = (p1.brightness + p2.brightness) / 2;

        ctx.strokeStyle = getColor(avgBrightness, avgBrightness);
        ctx.shadowColor = getColor(avgBrightness, 0.8);

        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
      }

      // Draw vertices
      ctx.shadowBlur = 15 * glowIntensity;
      for (var i = 0; i < projected.length; i++) {
        var p = projected[i];
        var radius = 4 + p.brightness * 2;

        ctx.fillStyle = getColor(p.brightness, p.brightness);
        ctx.shadowColor = getColor(p.brightness, 1.0);

        ctx.beginPath();
        ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
        ctx.fill();
      }

      frameCount++;
      lastTime = now;
      requestAnimationFrame(render);
    }

    // Flutter → JavaScript API
    window.vib34d = {
      // Switch visualization mode
      switchSystem: function(systemName) {
        currentMode = systemName;
        console.log('Switched to system:', systemName);
      },

      // Update visual parameters
      updateParameters: function(params) {
        if (params.rotationSpeedXW !== undefined) speedXW = params.rotationSpeedXW;
        if (params.rotationSpeedYW !== undefined) speedYW = params.rotationSpeedYW;
        if (params.rotationSpeedZW !== undefined) speedZW = params.rotationSpeedZW;
        if (params.hueShift !== undefined) hueShift = params.hueShift;
        if (params.glowIntensity !== undefined) glowIntensity = params.glowIntensity;
        if (params.vertexBrightness !== undefined) vertexBrightness = params.vertexBrightness;
        if (params.tessellationDensity !== undefined) tessellationDensity = params.tessellationDensity;
      },

      // Update audio data for reactivity
      updateAudio: function(data) {
        audioReactive.bass = data.bass || 0;
        audioReactive.mid = data.mid || 0;
        audioReactive.high = data.high || 0;
        audioReactive.energy = data.energy || 0;
      },

      // Get current state
      getState: function() {
        return {
          mode: currentMode,
          angleXW: angleXW,
          angleYW: angleYW,
          angleZW: angleZW,
          fps: fps
        };
      },

      // Reset rotation
      reset: function() {
        angleXW = 0;
        angleYW = 0;
        angleZW = 0;
      }
    };

    // Start rendering
    console.log('VIB34D 4D Hypercube Visualizer initialized');
    render();
  </script>
</body>
</html>
