<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>VIB34D Visual Systems</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      background: #020202;
      color: #cbe7ff;
      font-family: 'Space Mono', 'Courier New', monospace;
      overflow: hidden;
      touch-action: none;
    }

    #canvas-container {
      position: fixed;
      inset: 0;
      display: block;
      width: 100%;
      height: 100%;
    }

    canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
    }

    #fallback-message {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, rgba(0, 255, 255, 0.05), transparent 60%);
      pointer-events: none;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.2em;
    }
  </style>
</head>
<body>
  <div id="canvas-container" aria-hidden="true"></div>
  <div id="fallback-message">Initializing VIB34D visual stackâ€¦</div>

  <script src="./js/QuantumVisualizer.js"></script>
  <script src="./js/HolographicSystem.js"></script>
  <script src="./js/FacetedVisualizer.js"></script>

  <script>
    (function vib34dRuntime() {
      'use strict';

      const LAYER_CONFIG = [
        { role: 'background', reactivity: 0.5, zIndex: 0, domId: 'background-canvas' },
        { role: 'shadow', reactivity: 0.7, zIndex: 1, domId: 'shadow-canvas' },
        { role: 'content', reactivity: 0.9, zIndex: 2, domId: 'content-canvas' },
        { role: 'highlight', reactivity: 1.1, zIndex: 3, domId: 'highlight-canvas' },
        { role: 'accent', reactivity: 1.5, zIndex: 4, domId: 'accent-canvas' }
      ];

      const state = {
        lifecycle: 'booting',
        currentSystem: null,
        bootstrapped: false,
        activeVisualizers: [],
        commandQueue: [],
        audioReactive: { bass: 0, mid: 0, high: 0, energy: 0 },
        resizeRaf: null,
      };

      const container = document.getElementById('canvas-container');
      const fallback = document.getElementById('fallback-message');

      const SYSTEM_LIBRARY = {
        quantum: {
          label: 'Quantum Holographic Stack',
          instantiate: (layers) => layers.map(({ canvas, config }, index) =>
            new QuantumHolographicVisualizer(canvas.id, config.role, config.reactivity, index)
          ),
        },
        holographic: {
          label: 'Modular Holographic Suite',
          instantiate: () => [new HolographicSystem()],
        },
        faceted: {
          label: 'Faceted Resonance Array',
          instantiate: (layers) => layers.map(({ canvas, config }, index) =>
            new IntegratedHolographicVisualizer(canvas.id, config.role, config.reactivity, index)
          ),
        },
      };

      const notifyFlutter = (event, payload = {}) => {
        if (typeof FlutterBridge === 'undefined') return;
        try {
          FlutterBridge.postMessage(JSON.stringify({ event, ...payload }));
        } catch (error) {
          console.warn('FlutterBridge error', error);
        }
      };

      const setLifecycle = (phase, detail = {}) => {
        state.lifecycle = phase;
        notifyFlutter('viewer-lifecycle', {
          lifecycle: phase,
          message: detail.message,
          label: detail.label,
          system: detail.system ?? state.currentSystem,
          layers: detail.layers ?? state.activeVisualizers.length,
        });
      };

      const releaseContext = (gl) => {
        if (!gl) return;
        const ext = gl.getExtension && gl.getExtension('WEBGL_lose_context');
        if (ext && typeof ext.loseContext === 'function') {
          ext.loseContext();
        }
      };

      const destroyCurrentSystem = async () => {
        if (!state.activeVisualizers.length && !container.firstChild) return;
        setLifecycle('tearing-down', {
          system: state.currentSystem,
          message: `Releasing ${state.currentSystem ?? 'visualizer'} stack`,
        });

        state.activeVisualizers.forEach((visualizer) => {
          try {
            if (visualizer.stop) visualizer.stop();
            if (visualizer.destroy) visualizer.destroy();
            releaseContext(visualizer.gl);
          } catch (error) {
            console.warn('Visualizer destroy error', error);
          }
        });

        state.activeVisualizers = [];
        container.innerHTML = '';
        notifyFlutter('system-destroyed', { system: state.currentSystem });
        state.currentSystem = null;
      };

      const sizeCanvas = (canvas) => {
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        const rect = canvas.getBoundingClientRect();
        const width = rect.width || window.innerWidth;
        const height = rect.height || window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
      };

      const createLayerCanvases = (systemName) => {
        container.innerHTML = '';
        return LAYER_CONFIG.map((config) => {
          const canvas = document.createElement('canvas');
          canvas.id = config.domId;
          canvas.dataset.role = config.role;
          canvas.dataset.system = systemName;
          canvas.style.zIndex = config.zIndex;
          canvas.setAttribute('aria-label', `${systemName}-${config.role}-layer`);
          container.appendChild(canvas);
          sizeCanvas(canvas);
          return { canvas, config };
        });
      };

      const applyParameters = (params) => {
        if (!params || typeof params !== 'object') return;
        state.activeVisualizers.forEach((visualizer) => {
          try {
            if (typeof visualizer.applyParameters === 'function') {
              visualizer.applyParameters(params);
              return;
            }

            Object.keys(params).forEach((key) => {
              if (visualizer.params && key in visualizer.params) {
                visualizer.params[key] = params[key];
              }
            });
          } catch (error) {
            console.warn('Parameter application error', error);
          }
        });
      };

      const instantiateSystem = async (systemName) => {
        const descriptor = SYSTEM_LIBRARY[systemName];
        if (!descriptor) {
          notifyFlutter('system-error', {
            system: systemName,
            message: `Unknown system: ${systemName}`,
          });
          return;
        }

        const layers = createLayerCanvases(systemName);
        setLifecycle('initializing', {
          system: systemName,
          layers: layers.length,
          message: `Spinning up ${descriptor.label}`,
        });

        try {
          state.activeVisualizers = descriptor.instantiate(layers) || [];
          state.currentSystem = systemName;
          setLifecycle('ready', {
            system: systemName,
            layers: state.activeVisualizers.length,
            label: descriptor.label,
            message: `${descriptor.label} online`,
          });
          notifyFlutter('system-ready', {
            system: systemName,
            layers: state.activeVisualizers.length,
            label: descriptor.label,
          });
        } catch (error) {
          console.error('System instantiation error', error);
          notifyFlutter('system-error', {
            system: systemName,
            message: error?.message || String(error),
          });
          setLifecycle('faulted', { system: systemName });
        }
      };

      const queueCommand = (fn) => {
        if (!state.bootstrapped) {
          state.commandQueue.push(fn);
          return;
        }
        fn();
      };

      const flushCommandQueue = () => {
        if (!state.commandQueue.length) return;
        const queued = [...state.commandQueue];
        state.commandQueue = [];
        queued.forEach((fn) => {
          try {
            fn();
          } catch (error) {
            console.warn('Queued command error', error);
          }
        });
      };

      const swapSystem = async (systemName, force = false) => {
        if (!force && state.currentSystem === systemName) return;
        await destroyCurrentSystem();
        await instantiateSystem(systemName);
      };

      const handleResize = () => {
        cancelAnimationFrame(state.resizeRaf);
        state.resizeRaf = requestAnimationFrame(() => {
          container.querySelectorAll('canvas').forEach(sizeCanvas);
        });
      };

      const bootstrap = async () => {
        setLifecycle('booting', { message: 'Booting embedded VIB34D viewer' });
        try {
          await instantiateSystem('quantum');
        } finally {
          state.bootstrapped = true;
          flushCommandQueue();
          fallback.style.display = 'none';
          setLifecycle('ready', {
            system: state.currentSystem,
            label: SYSTEM_LIBRARY[state.currentSystem ?? 'quantum']?.label,
            message: 'Viewer ready',
          });
          notifyFlutter('viewer-ready', {
            system: state.currentSystem,
            label: SYSTEM_LIBRARY[state.currentSystem ?? 'quantum']?.label,
          });
        }
      };

      window.addEventListener('resize', handleResize, { passive: true });
      window.addEventListener('visibilitychange', () => {
        notifyFlutter('viewer-visibility', { hidden: document.hidden });
      });
      window.addEventListener('beforeunload', destroyCurrentSystem);

      const publicAPI = {
        switchSystem: (systemName, options) =>
          queueCommand(() => swapSystem(systemName, Boolean(options && options.force))),
        updateParameters: (params) => queueCommand(() => applyParameters(params)),
        updateAudio: (audio) => {
          state.audioReactive = { ...state.audioReactive, ...audio };
        },
        getState: () => ({
          lifecycle: state.lifecycle,
          system: state.currentSystem,
          layers: state.activeVisualizers.length,
          audioReactive: state.audioReactive,
        }),
        destroy: () => queueCommand(() => destroyCurrentSystem()),
      };

      window.vib34d = publicAPI;

      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        bootstrap();
      } else {
        document.addEventListener('DOMContentLoaded', bootstrap, { once: true });
      }
    })();
  </script>
</body>
</html>
