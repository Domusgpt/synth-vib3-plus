<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>VIB34D Visual Systems</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      background: #020202;
      color: #cbe7ff;
      font-family: 'Space Mono', 'Courier New', monospace;
      overflow: hidden;
      touch-action: none;
    }

    #canvas-container {
      position: fixed;
      inset: 0;
      display: block;
      width: 100%;
      height: 100%;
    }

    canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
    }

    #fallback-message {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, rgba(0, 255, 255, 0.05), transparent 60%);
      pointer-events: none;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.2em;
    }
  </style>
</head>
<body>
  <div id="canvas-container" aria-hidden="true"></div>
  <div id="fallback-message">Initializing VIB34D visual stack…</div>

  <script src="./js/QuantumVisualizer.js"></script>
  <script src="./js/HolographicSystem.js"></script>
  <script src="./js/FacetedVisualizer.js"></script>

  <script>
    (function vib34dRuntime() {
      'use strict';

      const DEFAULT_PARAMETER_STATE = {
        rotationSpeed: 1.0,
        tessellationDensity: 5,
        vertexBrightness: 0.8,
        hueShift: 180,
        glowIntensity: 1.0,
        rgbSplitAmount: 0.0,
        morphParameter: 0.0,
        projectionDistance: 8.0,
        layerSeparation: 2.0,
        rot4dXW: 0.0,
        rot4dYW: 0.0,
        rot4dZW: 0.0,
      };

      const LAYER_CONFIG = [
        { role: 'background', reactivity: 0.5, zIndex: 0, domId: 'background-canvas' },
        { role: 'shadow', reactivity: 0.7, zIndex: 1, domId: 'shadow-canvas' },
        { role: 'content', reactivity: 0.9, zIndex: 2, domId: 'content-canvas' },
        { role: 'highlight', reactivity: 1.1, zIndex: 3, domId: 'highlight-canvas' },
        { role: 'accent', reactivity: 1.5, zIndex: 4, domId: 'accent-canvas' }
      ];

      const state = {
        lifecycle: 'booting',
        currentSystem: null,
        bootstrapped: false,
        activeVisualizers: [],
        commandQueue: [],
        parameterSnapshot: { ...DEFAULT_PARAMETER_STATE },
        audioReactive: { bass: 0, mid: 0, high: 0, energy: 0 },
        resizeRaf: null,
        canvasGuards: [],
        switchInFlight: false,
        telemetryTimer: null,
        performance: {
          frameDurations: [],
          durationSum: 0,
          lastFrameTs: performance.now(),
          fps: 0,
          longestFrameMs: 0,
          droppedFrames: 0,
        },
        lastAudioTimestamp: null,
        warningFlags: {
          audio: false,
          raf: false,
        },
      };

      const container = document.getElementById('canvas-container');
      const fallback = document.getElementById('fallback-message');
      window.audioReactive = window.audioReactive || { ...state.audioReactive };
      window.audioEnabled = false;

      const SYSTEM_LIBRARY = {
        quantum: {
          label: 'Quantum Holographic Stack',
          instantiate: (layers) => layers.map(({ canvas, config }, index) =>
            new QuantumHolographicVisualizer(canvas.id, config.role, config.reactivity, index)
          ),
        },
        holographic: {
          label: 'Modular Holographic Suite',
          instantiate: () => [new HolographicSystem()],
        },
        faceted: {
          label: 'Faceted Resonance Array',
          instantiate: (layers) => layers.map(({ canvas, config }, index) =>
            new IntegratedHolographicVisualizer(canvas.id, config.role, config.reactivity, index)
          ),
        },
      };

      const notifyFlutter = (event, payload = {}) => {
        if (typeof FlutterBridge === 'undefined') return;
        try {
          FlutterBridge.postMessage(JSON.stringify({ event, ...payload }));
        } catch (error) {
          console.warn('FlutterBridge error', error);
        }
      };

      const trackFrameDuration = (timestamp) => {
        const perf = state.performance;
        const lastTs = perf.lastFrameTs ?? timestamp;
        const delta = timestamp - lastTs;
        perf.lastFrameTs = timestamp;
        if (!Number.isFinite(delta) || delta <= 0) return;
        const clamped = Math.min(Math.max(delta, 0), 1000);
        perf.frameDurations.push(clamped);
        perf.durationSum += clamped;
        if (perf.frameDurations.length > 180) {
          const removed = perf.frameDurations.shift();
          perf.durationSum -= removed;
        }
        if (perf.frameDurations.length) {
          const average = perf.durationSum / perf.frameDurations.length;
          perf.fps = average > 0 ? 1000 / average : 0;
        }
        perf.longestFrameMs = Math.max(clamped, perf.longestFrameMs * 0.9);
        if (clamped > 34) {
          perf.droppedFrames += 1;
        }
      };

      const instrumentRequestAnimationFrame = () => {
        if (window.__vib34dRafInstrumented) return;
        const nativeRAF = window.requestAnimationFrame.bind(window);
        window.requestAnimationFrame = (callback) =>
          nativeRAF((timestamp) => {
            trackFrameDuration(timestamp);
            callback(timestamp);
          });
        window.__vib34dRafInstrumented = true;
      };
      instrumentRequestAnimationFrame();

      const setLifecycle = (phase, detail = {}) => {
        state.lifecycle = phase;
        notifyFlutter('viewer-lifecycle', {
          lifecycle: phase,
          message: detail.message,
          label: detail.label,
          system: detail.system ?? state.currentSystem,
          layers: detail.layers ?? state.activeVisualizers.length,
        });
      };

      const releaseContext = (gl) => {
        if (!gl) return;
        const ext = gl.getExtension && gl.getExtension('WEBGL_lose_context');
        if (ext && typeof ext.loseContext === 'function') {
          ext.loseContext();
        }
      };

      const detachCanvasGuards = () => {
        state.canvasGuards.forEach(({ canvas, lostHandler, restoredHandler }) => {
          canvas.removeEventListener('webglcontextlost', lostHandler);
          canvas.removeEventListener('webglcontextrestored', restoredHandler);
        });
        state.canvasGuards = [];
      };

      const destroyCurrentSystem = async () => {
        if (!state.activeVisualizers.length && !container.firstChild) return;
        setLifecycle('tearing-down', {
          system: state.currentSystem,
          message: `Releasing ${state.currentSystem ?? 'visualizer'} stack`,
        });

        state.activeVisualizers.forEach((visualizer) => {
          try {
            if (visualizer.stop) visualizer.stop();
            if (visualizer.destroy) visualizer.destroy();
            releaseContext(visualizer.gl);
          } catch (error) {
            console.warn('Visualizer destroy error', error);
          }
        });

        state.activeVisualizers = [];
        container.innerHTML = '';
        detachCanvasGuards();
        notifyFlutter('system-destroyed', { system: state.currentSystem });
        state.currentSystem = null;
      };

      const sizeCanvas = (canvas) => {
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        const rect = canvas.getBoundingClientRect();
        const width = rect.width || window.innerWidth;
        const height = rect.height || window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
      };

      const attachCanvasGuards = (canvas, systemName) => {
        const lostHandler = (event) => {
          event.preventDefault();
          notifyFlutter('viewer-warning', {
            system: systemName,
            message: `WebGL context lost on ${canvas.id}`,
          });
          queueCommand(() => swapSystem(systemName, true));
        };
        const restoredHandler = () => {
          notifyFlutter('viewer-lifecycle', {
            lifecycle: 'recovering',
            system: systemName,
            message: `Restoring ${canvas.id}`,
          });
        };
        canvas.addEventListener('webglcontextlost', lostHandler, false);
        canvas.addEventListener('webglcontextrestored', restoredHandler, false);
        state.canvasGuards.push({ canvas, lostHandler, restoredHandler });
      };

      const createLayerCanvases = (systemName) => {
        container.innerHTML = '';
        detachCanvasGuards();
        return LAYER_CONFIG.map((config) => {
          const canvas = document.createElement('canvas');
          canvas.id = config.domId;
          canvas.dataset.role = config.role;
          canvas.dataset.system = systemName;
          canvas.style.zIndex = config.zIndex;
          canvas.setAttribute('aria-label', `${systemName}-${config.role}-layer`);
          container.appendChild(canvas);
          sizeCanvas(canvas);
          attachCanvasGuards(canvas, systemName);
          return { canvas, config };
        });
      };

      const dispatchParameters = (visualizer, params) => {
        if (!visualizer || !params) return;
        if (typeof visualizer.applyBridgeParameters === 'function') {
          visualizer.applyBridgeParameters(params);
          return;
        }
        if (typeof visualizer.applyParameters === 'function') {
          visualizer.applyParameters(params);
          return;
        }
        if (typeof visualizer.updateParameters === 'function') {
          visualizer.updateParameters(params);
        }
      };

      const applyParameters = (params) => {
        if (!params || typeof params !== 'object') return;
        state.parameterSnapshot = { ...state.parameterSnapshot, ...params };
        state.activeVisualizers.forEach((visualizer) => {
          try {
            dispatchParameters(visualizer, params);
          } catch (error) {
            console.warn('Parameter application error', error);
          }
        });
      };

      const reapplyParameterSnapshot = () => {
        if (!state.parameterSnapshot) return;
        state.activeVisualizers.forEach((visualizer) => {
          try {
            dispatchParameters(visualizer, state.parameterSnapshot);
          } catch (error) {
            console.warn('Snapshot dispatch error', error);
          }
        });
      };

      const propagateAudioSnapshot = () => {
        state.activeVisualizers.forEach((visualizer) => {
          if (typeof visualizer?.updateAudioReactive === 'function') {
            try {
              visualizer.updateAudioReactive({ ...state.audioReactive });
            } catch (error) {
              console.warn('Audio dispatch error', error);
            }
          }
        });
      };

      const instantiateSystem = async (systemName) => {
        const descriptor = SYSTEM_LIBRARY[systemName];
        if (!descriptor) {
          notifyFlutter('system-error', {
            system: systemName,
            message: `Unknown system: ${systemName}`,
          });
          return;
        }

        const layers = createLayerCanvases(systemName);
        notifyFlutter('system-initializing', {
          system: systemName,
          layers: layers.length,
          message: `Initializing ${descriptor.label}`,
        });
        setLifecycle('initializing', {
          system: systemName,
          layers: layers.length,
          message: `Spinning up ${descriptor.label}`,
        });

        try {
          state.activeVisualizers = descriptor.instantiate(layers) || [];
          state.currentSystem = systemName;
          reapplyParameterSnapshot();
          propagateAudioSnapshot();
          setLifecycle('ready', {
            system: systemName,
            layers: state.activeVisualizers.length,
            label: descriptor.label,
            message: `${descriptor.label} online`,
          });
          notifyFlutter('system-ready', {
            system: systemName,
            layers: state.activeVisualizers.length,
            label: descriptor.label,
          });
        } catch (error) {
          console.error('System instantiation error', error);
          notifyFlutter('system-error', {
            system: systemName,
            message: error?.message || String(error),
          });
          setLifecycle('faulted', { system: systemName });
        }
      };

      const queueCommand = (fn) => {
        if (!state.bootstrapped) {
          state.commandQueue.push(fn);
          return;
        }
        fn();
      };

      const flushCommandQueue = () => {
        if (!state.commandQueue.length) return;
        const queued = [...state.commandQueue];
        state.commandQueue = [];
        queued.forEach((fn) => {
          try {
            fn();
          } catch (error) {
            console.warn('Queued command error', error);
          }
        });
      };

      const swapSystem = async (systemName, force = false) => {
        if (!force && state.currentSystem === systemName) return;
        if (state.switchInFlight && !force) {
          state.commandQueue.push(() => swapSystem(systemName, force));
          return;
        }
        state.switchInFlight = true;
        try {
          await destroyCurrentSystem();
          await instantiateSystem(systemName);
        } finally {
          state.switchInFlight = false;
        }
      };

      const handleResize = () => {
        cancelAnimationFrame(state.resizeRaf);
        state.resizeRaf = requestAnimationFrame(() => {
          container.querySelectorAll('canvas').forEach(sizeCanvas);
        });
      };

      const emitTelemetry = () => {
        const now = performance.now();
        const perf = state.performance;
        const rafGapMs = Math.round(Math.max(0, now - (perf.lastFrameTs ?? now)));
        const audioStalenessMs = state.lastAudioTimestamp
          ? Math.max(0, now - state.lastAudioTimestamp)
          : null;

        const viewerHidden = document.hidden;
        if (viewerHidden) {
          state.warningFlags.audio = false;
          state.warningFlags.raf = false;
        } else {
          if (audioStalenessMs !== null && audioStalenessMs > 2500 && !state.warningFlags.audio) {
            notifyFlutter('viewer-warning', {
              system: state.currentSystem,
              message: 'Audio feed stale – no FFT data in >2.5s',
            });
            state.warningFlags.audio = true;
          }
          if (rafGapMs > 350 && !state.warningFlags.raf) {
            notifyFlutter('viewer-warning', {
              system: state.currentSystem,
              message: 'Render loop stalled – frame gap exceeded 350ms',
            });
            state.warningFlags.raf = true;
          }
        }

        notifyFlutter('viewer-telemetry', {
          lifecycle: state.lifecycle,
          system: state.currentSystem,
          layers: state.activeVisualizers.length,
          commandQueue: state.commandQueue.length,
          audioEnergy: Number(state.audioReactive?.energy ?? 0),
          timestamp: Date.now(),
          fps: Number(perf.fps?.toFixed?.(1) ?? perf.fps ?? 0),
          longestFrameMs: Number(perf.longestFrameMs?.toFixed?.(1) ?? perf.longestFrameMs ?? 0),
          droppedFrames: perf.droppedFrames,
          rafGapMs,
          audioStalenessMs: audioStalenessMs !== null ? Math.round(audioStalenessMs) : null,
          hidden: viewerHidden,
        });
      };

      const startTelemetry = () => {
        stopTelemetry();
        emitTelemetry();
        state.telemetryTimer = window.setInterval(emitTelemetry, 1000);
      };

      const stopTelemetry = () => {
        if (state.telemetryTimer) {
          clearInterval(state.telemetryTimer);
          state.telemetryTimer = null;
        }
      };

      const bootstrap = async () => {
        setLifecycle('booting', { message: 'Booting embedded VIB34D viewer' });
        try {
          await instantiateSystem('quantum');
        } finally {
          state.bootstrapped = true;
          flushCommandQueue();
          fallback.style.display = 'none';
          startTelemetry();
          setLifecycle('ready', {
            system: state.currentSystem,
            label: SYSTEM_LIBRARY[state.currentSystem ?? 'quantum']?.label,
            message: 'Viewer ready',
          });
          notifyFlutter('viewer-ready', {
            system: state.currentSystem,
            label: SYSTEM_LIBRARY[state.currentSystem ?? 'quantum']?.label,
          });
        }
      };

      window.addEventListener('resize', handleResize, { passive: true });
      window.addEventListener('visibilitychange', () => {
        state.performance.lastFrameTs = performance.now();
        state.warningFlags.audio = false;
        state.warningFlags.raf = false;
        notifyFlutter('viewer-visibility', { hidden: document.hidden });
      });
      window.addEventListener('beforeunload', () => {
        stopTelemetry();
        destroyCurrentSystem();
      });

      const publicAPI = {
        switchSystem: (systemName, options) =>
          queueCommand(() => swapSystem(systemName, Boolean(options && options.force))),
        updateParameters: (params) => queueCommand(() => applyParameters(params)),
        updateAudio: (audio) => {
          state.audioReactive = { ...state.audioReactive, ...audio };
          window.audioReactive = { ...state.audioReactive };
          window.audioEnabled = true;
          state.lastAudioTimestamp = performance.now();
          state.warningFlags.audio = false;
          propagateAudioSnapshot();
        },
        getState: () => ({
          lifecycle: state.lifecycle,
          system: state.currentSystem,
          layers: state.activeVisualizers.length,
          audioReactive: state.audioReactive,
        }),
        destroy: () => queueCommand(() => destroyCurrentSystem()),
        forceReload: () => queueCommand(() => swapSystem(state.currentSystem ?? 'quantum', true)),
        getTelemetry: () => ({
          lifecycle: state.lifecycle,
          system: state.currentSystem,
          layers: state.activeVisualizers.length,
          commandQueue: state.commandQueue.length,
          audioEnergy: state.audioReactive?.energy ?? 0,
          fps: state.performance.fps,
          rafGapMs: Math.max(0, performance.now() - (state.performance.lastFrameTs ?? performance.now())),
          audioStalenessMs: state.lastAudioTimestamp
            ? Math.max(0, performance.now() - state.lastAudioTimestamp)
            : null,
        }),
      };

      window.vib34d = publicAPI;

      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        bootstrap();
      } else {
        document.addEventListener('DOMContentLoaded', bootstrap, { once: true });
      }
    })();
  </script>
</body>
</html>
